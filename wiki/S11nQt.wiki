#summary Utility code for serializing Qt data using libs11n

= Serializing Qt-based objects using libs11n =

Since i'm the maintainer of the s11n project (http://s11n.net), a library for serializing
objects in C++, QBoard uses libs11n for its serialization needs (that is, loading and saving). As QBoard develops, code is written to bind Qt-based types to the s11n serialization framework. That code is independent of QBoard and may be helpful to coders working on arbitrary Qt-based projects. (Historical note: libs11n was originally written with the express intent of (someday) supporting this very application.)

The code is available via the QBoard source tree (look for `src/*11n*.*`) or as a separate download on the downloads page (look for `s11n-qt-VERSION.tar.gz`, though those versions may be older than what is the in the current QBoard tree).

The distribution contains code for de/serializing the following Qt types:

|| *Type* || *Notes* ||
|| QBitArray || Packs the bits into blocks of 32-bit integers. ||
|| QByteArray || Bin64-encoded. Objects over a certain (configurable) size will be compressed with zlib. ||
|| QBrush || All significant properties are stored, including custom transformations and textures. ||
|| QColor || RGBA data ||
|| QDate/QTime/QDateTime || ||
|| QFont || ||
|| QLine/QLineF || ||
|| QList/QVector || May contain any Serializable type (as defined by libs11n) ||
|| QMap || May contain any Serializable type (as defined by libs11n) ||
|| QMatrix || ||
|| QRect/QRectF || ||
|| QPair || May contain any Serializable type (as defined by libs11n) ||
|| QPen || All properties handled, including custom dash patterns. ||
|| QRegExp || ||
|| QPixmap || Stored as a QByteArray ||
|| QPoint/QPointF || ||
|| QPolygon || Actually `QVector<QPoint>` ||
|| QSize/QSizeF || ||
|| QString || Handles both ASCII and Unicode strings (using a different internal representation for each). ||
|| QTransform || ||
|| QVariant || Many forms are supported, including above-listed types. With a little help (see below) it can work with any Serializable Type object. ||

After including the proper header file(s) (which register(s) a specific Qt type with libs11n), one can use those types via the s11nlite API, e.g.:

{{{
#include "S11nQt.h"
#include "S11Qt/QPoint.h"
#include "S11Qt/QVariant.h"
#include "S11Qt/QRectF.h"
...

QPoint p(20,30);
s11nlite::save( p, std::cout );
QVariant var( QRectF(23.3,34.4,27,94) );
s11nlite::save( var, std::cout );
}}}


S11nQt also comes with proxy objects which allow QIODevices to be used via the STL i/ostream interfaces (so you can e.g. save s11n data out to a QFile instead of a std::ofile).

This code is central to QBoard's save/load and copy/paste features and is believed to work quite well.

Suggestions, fixes, etc., are of course always welcome.

Happy hacking!

= QVariant and Serializables =

Probably the most interesting part of the QVariant/S11n support is the ability to store arbitrary Serializable types (as defined by libs11n) in QVariants, and then pass them around. To store a Serializable in a QVariant we need to use a proxy type. That looks like this:

{{{
#include "S11nQt.h"
#include "S11nQt/QVariant.h"
using namespace s11n::qt;
...
QVariant var( VariantS11n(mySerializable) );
}}}

To deserialize it, we do:

{{{
if( var.canConvert<VariantS11n>() )
{
  VariantS11n sv( myVariant.value<VariantS11n>() );
  MySerializable * my = sv.deserialize<MySerializable>();
  ...
}
}}}

= Serializing QObjects, QWidgets, etc. =

S11nQt doesn't have routines for directly serializing QObject trees, but:

  * Doing so is fairly trivial. We can easily serialize the parent/child trees.
  * We cannot easily serialize the signal/slot connections, mainly because such connections may span across object hierarchies and s11n's pointer-following policy doesn't play well with that.

It might be possible to de/serialize signal/slot connections by introducing another pass to the serialization process, where we tag all related objects, add that tag info to their serialized output, and re-build the connections from those tags during deserialization. Signals and slots are internally referred to by their stringified names, so that's not the problem. It's finding the correct object to reconnect to at deserialization time, that's the problem.

That said, it is possible (and trivial) to serialize QObject trees, and QBoard does so in several places.